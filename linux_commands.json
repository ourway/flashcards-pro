[
  {
    "question": "What is the `man` command and how do you use it to get help?",
    "answer": "**`man` (manual pages)**\n\n**Purpose:** The `man` command is your primary way to access the built-in manual pages in Linux. It displays detailed documentation for commands, system calls, libraries, and more.\n\n**Basic Syntax:**\n`bash\nman [COMMAND_NAME]\n`\n\n**Usage & Details:**\n*   **`man COMMAND_NAME`:** Displays the manual page for `COMMAND_NAME`. For example, `man ls` will show the manual for the `ls` command.\n*   **Navigation within `man` pages:**\n    *   Use the **arrow keys** (↑, ↓, ←, →), **Page Up**, **Page Down**, **Spacebar** to navigate.\n    *   **`/` (forward search):** Type `/` followed by a keyword and press Enter to search for that keyword within the page. Use `n` to go to the next match and `N` for the previous.\n    *   **`?` (backward search):** Similar to `/` but searches backward.\n    *   **`h` (help):** Displays a help page with navigation commands within `man`.\n    *   **`q` (quit):** Exits the `man` page viewer.\n*   **Manual Page Sections:** Manual pages are organized into sections, indicated by a number at the top. Common sections include:\n    *   `1`: User commands (what you type in the shell)\n    *   `2`: System calls (functions the kernel provides)\n    *   `3`: Library functions (functions in standard libraries)\n    *   `5`: File formats and conventions (e.g., `/etc/passwd`)\n    *   `8`: System administration commands (often for root only)\n*   **Specifying Sections:** If a word exists in multiple sections, you can specify a section to view using `man SECTION COMMAND_NAME`. For example, `man 2 read` to see the manual page for the `read` system call (section 2), not the `read` shell built-in command (section 1, if it exists).\n*   **`whatis COMMAND_NAME`:**  A faster way to get a very brief, one-line description of a command.  `man -f COMMAND_NAME` is equivalent.\n*   **`apropos KEYWORD`:**  Searches manual page names and descriptions for `KEYWORD`.  `man -k KEYWORD` is equivalent. Useful when you don't know the exact command name but have a general idea of what you want to do.\n\n**Example:**\n`bash\nman ls         # View the manual page for the 'ls' command.\nman 5 passwd     # View the manual page for the 'passwd' file format (section 5).\nwhatis grep    # Get a one-line description of 'grep'.\napropos directory # Search for commands related to 'directory'.\n`\n\n**Importance:** `man` is indispensable for understanding commands, options, and how to use Linux effectively. Get comfortable using it!",
    "reference": "https://ss64.com/bash/man.html"
  },
  {
    "question": "How do you redirect standard error (stderr) to a file?",
    "answer": "**Redirecting Standard Error (stderr)**\n\n**Purpose:** Sometimes you want to capture error messages (standard error) that commands produce, instead of just seeing them on the terminal.  You can redirect stderr to a file.\n\n**Redirection Operator for stderr:**\n*   `2>` **(Stderr Redirection - Overwrite)**: Redirects standard error to a file, overwriting it if it exists.\n*   `2>>` **(Stderr Redirection - Append)**: Redirects standard error to a file, appending to it if it exists.\n\n**File Descriptor 2:** In Linux, file descriptor `2` represents standard error (stderr). File descriptor `1` is stdout, and `0` is stdin.\n\n**Basic Syntax:**\n`bash\nCOMMAND 2> ERROR_FILE\nCOMMAND 2>> ERROR_FILE\n`\n\n**Examples:**\n`bash\nls nonexistent_file.txt > output.txt 2> error_log.txt\n# If 'nonexistent_file.txt' doesn't exist, 'ls' will produce an error message (stderr).\n# The error message will be saved to 'error_log.txt'.\n# The standard output (if there was any, in this case, none) would go to 'output.txt'.\n\ncommand_that_might_fail 2>> error_log.txt # Append stderr from 'command_that_might_fail' to 'error_log.txt'.\n`\n\n**Redirecting both stdout and stderr to separate files:**\n`bash\nCOMMAND > output.txt 2> error.txt\n`\n\n**Redirecting both stdout and stderr to the same file (combined):**\n*   **Using `&>` (Bash 4 and later):**\n    `bash\n    COMMAND &> combined.log\n    `\n*   **Using `2>&1` (Portable, works in most shells):**\n    `bash\n    COMMAND > combined.log 2>&1\n    # Explanation of 2>&1:\n    #  - `>` redirects stdout (file descriptor 1) to 'combined.log'.\n    #  - `2>&1` redirects stderr (file descriptor 2) to where file descriptor 1 is currently pointing (which is 'combined.log').\n    `\n\n**Use Cases:**\n*   **Capturing error messages:**  Essential for debugging scripts or commands, especially when running them in the background or automating tasks.\n*   **Separating normal output from errors:** Keeps output files cleaner by putting error messages in a dedicated error log.\n*   **Troubleshooting and logging:** Helpful for diagnosing issues and tracking command failures.",
    "reference": "https://ss64.com/bash/syntax-redirection.html"
  },
  {
    "question": "What is the `history` command and how can you use it effectively?",
    "answer": "**`history` command**\n\n**Purpose:** The `history` command is used to display the command history - a list of commands you have previously entered in your current shell session and potentially across sessions (depending on configuration).\n\n**Basic Syntax:**\n`bash\nhistory [OPTION]... [NUMBER]\n`\n\n**Common Uses & Details:**\n*   **`history` (no options):** Displays the entire command history list (or the last part of it, depending on your `HISTSIZE` and `HISTFILESIZE` environment variables). Each command is usually numbered.\n*   **`history NUMBER`:** Displays the last `NUMBER` commands from the history. For example, `history 10` shows the last 10 commands.\n*   **`!NUMBER`:** Re-executes the command with the history number `NUMBER`. For example, if `history` shows command number `123` as `ls -l`, then `!123` will run `ls -l` again.\n*   **`!STRING`:** Re-executes the most recent command from history that starts with `STRING`. For example, if you previously ran `grep error logfile.txt`, you can run `!grep` to execute `grep error logfile.txt` again.\n*   **`!!`:** Re-executes the previous command (same as `!-1`).\n*   **`!-n`:** Re-executes the command that was executed `n` commands ago. For example, `!-2` re-runs the command before the previous one.\n*   **`Ctrl+R` (Reverse-i-search):** Press `Ctrl+R` and start typing a part of a command. The shell will search backward in your history for commands matching what you type. Press `Ctrl+R` again to cycle through more matches. Press Enter to execute the found command, or Esc/Ctrl+G to cancel the search.\n*   **`Ctrl+J` or `Enter` after `Ctrl+R` search:** Executes the found command.\n*   **`Ctrl+G` or `Esc` after `Ctrl+R` search:** Cancels the history search.\n*   **`history -c` (clear):** Clears the current history list in memory. This does *not* typically clear the history file on disk immediately (it's usually written to disk when the shell session ends).\n*   **`history -w` (write):** Writes the current history list to the history file (usually `~/.bash_history`). Useful if you want to save the current session's history immediately.\n*   **`history -r` (read):** Reads the history file into the current history list, merging it with the current session's history.\n*   **`HISTSIZE` and `HISTFILESIZE` environment variables:** Control how many commands are stored in memory (`HISTSIZE`) and in the history file (`HISTFILESIZE`).\n\n**Effective Use:**\n*   **Recalling and re-executing commands:**  Especially useful for long or complex commands you need to run again, or commands you ran recently but don't want to retype.\n*   **Correcting mistakes:** If you made a typo in a long command, you can use `history`, find the command, edit it with shell editing features (e.g., using arrow keys, Ctrl+A, Ctrl+E, etc.), and then re-run it.\n*   **Auditing and tracking:** `history` can help you remember what commands you ran in a session, which can be useful for auditing your work or retracing steps.\n*   **Efficiency:** Using history shortcuts like `!NUMBER`, `!STRING`, and `!!` can significantly speed up command-line work.",
    "reference": "https://ss64.com/bash/history.html"
  },
  {
    "question": "What is the `clear` command?",
    "answer": "**`clear` command**\n\n**Purpose:** The `clear` command is very simple: it clears your terminal screen, removing all previously displayed output, giving you a fresh, blank screen at the top.\n\n**Basic Syntax:**\n`bash\nclear\n`\n\n**Usage & Details:**\n*   **`clear` (no options or arguments):**  Simply typing `clear` and pressing Enter will clear the terminal screen.\n*   **How it works:** `clear` typically works by sending a special control sequence to your terminal that tells it to erase the screen and reset the cursor to the top-left corner.\n*   **History remains:** `clear` only clears the *display*. It does not erase your command history, environment variables, or change the state of your shell in any way other than visually cleaning the screen. You can still scroll back in your terminal's buffer to see previous output (depending on your terminal settings).\n\n**Example:**\n`bash\nls -l\n# ... lots of output on the screen ...\nclear        # Clears the screen, previous 'ls -l' output is no longer visible on the screen.\n`\n\n**Use Cases:**\n*   **Decluttering the terminal:** When your terminal becomes cluttered with command output and you want a clean workspace.\n*   **Improving readability:** After running several commands or viewing long outputs, `clear` helps to focus on the current task without distractions from previous output.\n*   **Presentation and demos:** Useful when giving demos or presentations on the command line to start with a clean screen for each step.",
    "reference": "https://ss64.com/bash/clear.html"
  },
  {
    "question": "What is the `uname` command and what information can you get with it?",
    "answer": "**`uname` (print system information)**\n\n**Purpose:** The `uname` command displays system information, such as the operating system name, kernel version, hardware architecture, and more.\n\n**Basic Syntax:**\n`bash\nuname [OPTION]...\n`\n\n**Common Options & Details:**\n*   **`uname` (no options):** By default, `uname` prints the operating system kernel name (typically 'Linux').\n*   **`-s` or `--kernel-name`:** Print the kernel name (same as default).\n*   **`-n` or `--nodename`:** Print the system's hostname (network node hostname).\n*   **`-r` or `--kernel-release`:** Print the kernel release version.\n*   **`-v` or `--kernel-version`:** Print the kernel version.\n*   **`-m` or `--machine`:** Print the machine hardware name (e.g., 'x86_64', 'i686', 'armv7l').\n*   **`-p` or `--processor`:** Print the processor type or architecture (may be unknown on some architectures).\n*   **`-i` or `--hardware-platform`:** Print the hardware platform (may be unknown on some architectures).\n*   **`-o` or `--operating-system`:** Print the operating system name (e.g., 'GNU/Linux').\n*   **`-a` or `--all`:** Print all information (-snrvmpio) in the following order: kernel name, nodename, kernel release, kernel version, machine, processor, hardware platform, operating system.\n\n**Examples:**\n`bash\nuname                  # Output: Linux (kernel name)\nuname -s               # Output: Linux (kernel name)\nuname -n               # Output: your-hostname (system's hostname)\nuname -r               # Output: 5.15.0-86-generic (kernel release version, example)\nuname -v               # Output: #96~20.04.2-Ubuntu SMP Tue Oct 10 13:17:15 UTC 2023 (kernel version, example)\nuname -m               # Output: x86_64 (machine architecture, example)\nuname -p               # Output: x86_64 (processor type, example)\nuname -o               # Output: GNU/Linux (operating system)\nuname -a               # Output: Linux your-hostname 5.15.0-86-generic #96~20.04.2-Ubuntu SMP Tue Oct 10 13:17:15 UTC 2023 x86_64 x86_64 GNU/Linux (all info)\n`\n\n**Use Cases:**\n*   **Identifying system architecture:** To determine if you are on a 32-bit or 64-bit system (using `-m`).\n*   **Getting kernel version information:** For troubleshooting, system compatibility checks, or reporting system details (using `-r` and `-v`).\n*   **Scripting:** In scripts, `uname` can be used to make decisions based on the operating system or hardware architecture the script is running on (e.g., to handle platform-specific differences).\n*   **System information gathering:** For general system identification and inventory purposes.",
    "reference": "https://ss64.com/bash/uname.html"
  },
  {
    "question": "What is the `ps` command and how is it used to list processes?",
    "answer": "**`ps` (process status)**\n\n**Purpose:** The `ps` command displays information about currently running processes. Unlike `top`, `ps` provides a static snapshot of processes at the moment it is executed, rather than a real-time, updating view. It is highly configurable and can show a wide range of process information.\n\n**Basic Syntax:**\n`bash\nps [OPTIONS]\n`\n\n**Options and Output Format:** `ps` has a somewhat complex option system with different option styles (Unix-style, BSD-style, GNU-style) that can be mixed and matched. Some common and useful options:\n\n*   **Basic Process Listing (Unix-style options, most common):**\n    *   **`ps aux`:**  A very common combination that displays a comprehensive list of processes running on the system, including those from other users. \n        *   `a`:  List processes for all users.\n        *   `u`:  Display user-oriented format (shows username, CPU and memory usage in percentages).\n        *   `x`:  List processes without controlling terminals (includes daemons, background processes, etc.).\n    *   **`ps -ef`:** Another common way to get a full process list, often similar to `ps aux`, using slightly different options.\n        *   `-e`: Select all processes.\n        *   `-f`: Full format listing (shows more details, like PPID, C, STIME, TTY, TIME).\n*   **User-Specific Processes:**\n    *   **`ps -u username`:** List processes owned by the user `username`. For example, `ps -u john`.  (Unix-style option).\n    *   **`ps u`:** List processes of the current user in user-oriented format. (BSD-style option - note no hyphen).\n*   **Process Tree:**\n    *   **`ps axjf`:** Display processes in a tree format, showing parent-child process relationships. Useful to visualize process hierarchy.\n        *   `j`: Jobs format (shows process group and session leaders).\n        *   `f`: ASCII art forest (tree) display.\n*   **Selecting by PID:**\n    *   **`ps -p PID,PID,...`:** List information for specific processes by their PIDs. For example, `ps -p 1234,5678`. (Unix-style option).\n*   **Output Format Control:**\n    *   **`-o format` or `--format format`:**  Customize the output columns. You specify a comma-separated list of format keywords. Many keywords are available.  Example: `ps -o pid,user,%cpu,%mem,command`\n\n**Commonly Used Output Columns (with `ps aux` or `ps -ef`):**\n*   **USER:** Username of the process owner.\n*   **PID:** Process ID.\n*   **%CPU:** Percentage of CPU time used by the process since last refresh (for `ps`, this is typically since the process started, or a very short interval).\n*   **%MEM:** Percentage of physical memory used by the process.\n*   **VSZ:** Virtual memory size of the process (in kilobytes).\n*   **RSS:** Resident set size - the non-swapped physical memory the process is using (in kilobytes).\n*   **TTY:** Controlling terminal associated with the process (if any, `?` means no controlling terminal).\n*   **STAT:** Process state codes (e.g., `S` - sleeping, `R` - running, `Z` - zombie).\n*   **START:** Time the process started.\n*   **TIME:** Cumulative CPU time used by the process since it started.\n*   **COMMAND:** Command and arguments used to start the process.\n\n**Examples:**\n`bash\nps aux               # Comprehensive process list (very common).\nps -ef                # Another full process list format.\nps -u myusername       # Processes owned by 'myusername'.\nps u                  # Processes of the current user.\nps axjf              # Process tree view.\nps -p 1234,5678        # Information for PIDs 1234 and 5678.\nps -o pid,user,command # Custom output format: PID, USER, COMMAND.\nps -o pid,ppid,%cpu,%mem,command # PID, PPID, CPU%, MEM%, COMMAND (good for debugging).\n`\n\n**Use Cases:**\n*   **Listing all running processes or processes of a specific user.**\n*   **Identifying the PID of a process.**\n*   **Monitoring resource usage of processes (CPU, memory).**\n*   **Troubleshooting running applications or background tasks.**\n*   **Scripting:** `ps` is often used in scripts to check if a process is running, get its PID, or monitor its resource consumption.",
    "reference": "https://ss64.com/bash/ps.html"
  },
  {
    "question": "What are `gzip` and `gunzip` commands used for?",
    "answer": "**`gzip` and `gunzip` (GNU zip and GNU unzip)**\n\n**Purpose:** `gzip` is a compression utility that reduces the size of files using Lempel-Ziv coding (LZ77). `gunzip` is the decompression utility for files compressed with `gzip`.\n\n**`gzip` - Purpose:** To compress files, typically resulting in files with a `.gz` extension.\n\n**`gzip` - Basic Syntax:**\n`bash\ngzip [OPTION]... [FILE]...\n`\n\n**`gzip` - Common Options:**\n*   **`gzip FILE`:** Compresses `FILE` and replaces it with `FILE.gz`. The original `FILE` is deleted by default.\n*   **`-c` or `--stdout` or `--to-stdout`:** Write compressed output to standard output, keep original files.  Useful with redirection.\n    *   Example: `gzip -c file.txt > file.txt.gz` (compresses `file.txt` and writes compressed output to `file.txt.gz`, keeps original `file.txt`).\n*   **`-d` or `--decompress` or `--uncompress`:** Decompress. Same as `gunzip`. If you use `gzip -d file.txt.gz`, it will decompress `file.txt.gz` and replace it with `file.txt` (original `.gz` file is deleted).\n*   **`-k` or `--keep`:** Keep (don't delete) input files during compression or decompression.\n*   **`-l` or `--list`:** List compressed file contents (for `.gz` files). Shows compressed and uncompressed sizes, ratio.\n*   **`-r` or `--recursive`:** Recursively compress files in directories.\n*   **`-v` or `--verbose`:** Verbose output - show compression ratio and filenames.\n*   **`-数字` (compression level 1-9, default 6):** Specify compression level, from `1` (fastest, least compression) to `9` (slowest, best compression). `-1` or `--fast` for fastest, `-9` or `--best` for best compression. Default is `-6`. `-0` or `--no-name` is no compression (just stores file).\n*   `-f` or `--force`: Force compression even if the file is already compressed, or when linking/unlinking.\n\n**`gunzip` - Purpose:** To decompress files compressed with `gzip`, typically `.gz` files.\n\n**`gunzip` - Basic Syntax:**\n`bash\ngunzip [OPTION]... [FILE]...\n`\n\n**`gunzip` - Common Options:**\n*   **`gunzip FILE.gz`:** Decompresses `FILE.gz` and replaces it with `FILE` (original `.gz` file is deleted by default).\n*   **`-c` or `--stdout` or `--to-stdout`:** Write decompressed output to standard output, keep original compressed file. Useful with redirection.\n    *   Example: `gunzip -c file.txt.gz > file.txt` (decompresses `file.txt.gz` and writes decompressed output to `file.txt`, keeps original `file.txt.gz`).\n*   **`-k` or `--keep`:** Keep (don't delete) compressed input files during decompression.\n*   **`-l` or `--list`:** List compressed file contents (for `.gz` files). Same as `gzip -l`.\n*   **`-r` or `--recursive`:** Recursively decompress files in directories.\n*   **`-v` or `--verbose`:** Verbose output.\n*   `-f` or `--force`: Force decompression even if the file already exists, or when linking/unlinking.\n\n**Alternative: `zcat` or `gzip -cat`:** To view the content of a `.gz` file without decompressing it to disk, use `zcat file.txt.gz` or `gzip -cat file.txt.gz | less` (pipe to `less` for paging).\n\n**Examples:**\n`bash\ngzip file.txt                # Compress 'file.txt' to 'file.txt.gz' (original deleted).\ngzip -k file.txt             # Compress 'file.txt' to 'file.txt.gz', keep 'file.txt'.\ngzip -c file.txt > file.gz   # Compress 'file.txt', output to 'file.gz', keep 'file.txt'.\ngzip -9 very_large_file.txt # Compress with best compression (slowest).\ngzip -r directories/         # Recursively compress all files in 'directories/'.\ngzip -l archive.log.gz       # List content info of 'archive.log.gz'.\n\ngunzip file.txt.gz              # Decompress 'file.txt.gz' to 'file.txt' (original .gz deleted).\ngunzip -k file.txt.gz           # Decompress 'file.txt.gz' to 'file.txt', keep 'file.txt.gz'.\ngunzip -c file.gz > file.txt  # Decompress 'file.gz', output to 'file.txt', keep 'file.gz'.\ngunzip -r compressed_directories/ # Recursively decompress .gz files in 'compressed_directories/'.\nzcat log.gz | grep error    # View content of 'log.gz' and pipe to 'grep' to search for 'error'.\n`\n\n**File Extensions:** `gzip` typically uses `.gz` as the extension for compressed files. `gunzip` automatically recognizes and handles `.gz` files.\n\n**Use Cases:**\n*   **Compressing files to save disk space.**\n*   **Reducing file sizes for faster transfer over networks.**\n*   **Archiving and distribution of data (often used in `.tar.gz` archives).**\n*   **Log file compression.**\n*   **Viewing compressed file contents without full decompression (using `zcat` or `gzip -cat`).**",
    "reference": "https://ss64.com/bash/gzip.html https://ss64.com/bash/gunzip.html"
  },
    {
    "question": "What are `zip` and `unzip` commands used for?",
    "answer": "**`zip` and `unzip` commands**\n\n**Purpose:** `zip` is used to create ZIP archives, which are a common archive format, especially for exchanging files with Windows users. `unzip` is used to extract files from ZIP archives.\n\n**`zip` - Purpose:** To create ZIP archive files (typically with a `.zip` extension).\n\n**`zip` - Basic Syntax:**\n`bash\nzip [OPTION]... ZIPFILE [FILE]...\n`\n\n**`zip` - Common Options:**\n*   **`zip archive.zip file1 file2 directory1`:** Creates a ZIP archive named `archive.zip` containing `file1`, `file2`, and the contents of `directory1`.\n*   **`-r` or `--recurse-directories`:**  Recurse into directories to include their contents in the archive. Required to archive directories.\n*   **`-j` or `--junk-paths`:** Store just the names of files, not the paths. Useful if you only want the files themselves in the archive, not the directory structure.\n*   **`-q` or `--quiet`:** Quiet mode; suppress most messages.\n*   **`-v` or `--verbose`:** Verbose mode; display more information.\n*   **`-e` or `--encrypt`:** Encrypt the ZIP archive with a password. You will be prompted to enter a password.\n*   **`-l` or `--list`:** List contents of an existing ZIP archive without extracting.\n*   **`-d` or `--delete`:** Delete entries from a ZIP archive. `zip -d archive.zip file_to_delete`.\n*   **`-u` or `--update`:** Update existing entries and add new ones to a ZIP archive.\n*   **`-m` or `--move`:** Move the specified files into the ZIP archive; delete the original files after successful creation of archive entries.\n*   **`-数字` (compression level 0-9, default 6):** Specify compression level, from `0` (store only, no compression) to `9` (maximum compression, slowest). `-0` or `--store` for no compression, `-9` or `--best` for best compression.\n\n**`unzip` - Purpose:** To extract files from ZIP archives.\n\n**`unzip` - Basic Syntax:**\n`bash\nunzip [OPTION]... ZIPFILE [FILE]...\n`\n\n**`unzip` - Common Options:**\n*   **`unzip archive.zip`:** Extracts all files from `archive.zip` into the current directory.\n*   **`-l` or `--list`:** List the contents of a ZIP archive without extracting.\n*   **`-v` or `--verbose`:** Verbose mode; list all extracted files.\n*   **`-q` or `--quiet`:** Quiet mode; suppress most messages.\n*   **`-o` or `--overwrite`:** Overwrite existing files without prompting during extraction.\n*   **`-n` or `--no-overwrite`:** Never overwrite existing files during extraction. Skip files that would overwrite existing ones.\n*   **`-d DIRECTORY`:** Extract files into `DIRECTORY` instead of the current directory. `unzip archive.zip -d /tmp/extracted_files`.\n*   **`-j` or `--junkpaths`:** Junk paths; extract files without creating directories. All files are extracted into the destination directory (or current directory if no `-d` is used) regardless of their paths in the ZIP archive.\n*   **`-t` or `--test`:** Test archive file integrity (checks if the archive is valid and extractable) without actually extracting files.\n*   **`-P password`:**  Provide a password for encrypted ZIP archives on the command line (less secure than being prompted).\n\n**Examples:**\n`bash\nzip myarchive.zip file1.txt directory1  # Create 'myarchive.zip' with file and directory.\nzip -r myarchive.zip directory2        # Create 'myarchive.zip' including 'directory2' and its contents (recursive).\nzip -e encrypted.zip files.txt          # Create password-protected 'encrypted.zip'.\nzip -q archive.zip file_to_add.txt    # Add 'file_to_add.txt' to 'archive.zip' in quiet mode.\nzip -d archive.zip unwanted_file.txt  # Delete 'unwanted_file.txt' from 'archive.zip'.\nzip -l archive.zip                  # List content of 'archive.zip'.\n\nunzip archive.zip                  # Extract 'archive.zip' to current directory.\nunzip -l archive.zip               # List contents of 'archive.zip' (same as 'zip -l').\nunzip -d /tmp/extract_here archive.zip # Extract to '/tmp/extract_here' directory.\nunzip -o archive.zip               # Overwrite existing files during extraction.\nunzip -j archive.zip               # Extract files ignoring directory paths within the archive.\nunzip -t archive.zip               # Test archive integrity.\nunzip -P mysecretpassword encrypted.zip # Extract password-protected archive with password provided on command line.\n`\n\n**File Extensions:** `zip` creates files typically with the `.zip` extension. `unzip` automatically handles `.zip` files.\n\n**Use Cases:**\n*   **Creating ZIP archives for compatibility with Windows and other systems that commonly use ZIP format.**\n*   **Compressing and archiving files for distribution or backup.**\n*   **Creating password-protected ZIP archives for security.**\n*   **Extracting files from ZIP archives.**\n*   **Software distribution (ZIP archives are also used for some software packages).**",
    "reference": "https://ss64.com/bash/zip.html https://ss64.com/bash/unzip.html"
  }
]
